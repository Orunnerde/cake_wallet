import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

// This file is automatically generated. DO NOT EDIT, all your changes would be lost.
class S implements WidgetsLocalizations {
  const S();

  static S current;

  static const GeneratedLocalizationsDelegate delegate =
    GeneratedLocalizationsDelegate();

  static S of(BuildContext context) => Localizations.of<S>(context, S);

  @override
  TextDirection get textDirection => TextDirection.ltr;

  String get account => "Account";
  String get accounts => "Accounts";
  String get add => "Add";
  String get address_book => "Address Book";
  String get address_book_menu => "Address book";
  String get all => "ALL";
  String get amount => "Amount: ";
  String get amount_is_estimate => "The receive amount is an estimate";
  String get amount_is_guaranteed => "The receive amount is guaranteed";
  String get authenticated => "Authenticated";
  String get authentication => "Authentication";
  String get cancel => "Cancel";
  String get change => "Change";
  String get change_currency => "Change Currency";
  String get change_exchange_provider => "Change Exchange Provider";
  String get clear => "Clear";
  String get confirm => "Confirm";
  String get confirm_sending => "Confirm sending";
  String get contact => "Contact";
  String get contact_name => "Contact Name";
  String get continue_text => "Continue";
  String get copied_to_clipboard => "Copied to Clipboard";
  String get copy => "Copy";
  String get copy_address => "Copy Address";
  String get copy_id => "Copy ID";
  String get create_new => "Create new";
  String get delete => "Delete";
  String get digit_pin => "-digit Pin";
  String get edit => "Edit";
  String get enter_your_pin => "Enter your PIN";
  String get error => "Error";
  String get estimated => "Estimated";
  String get exchange => "Exchange";
  String get exchange_result_write_down_ID => "*Please copy or write down your ID shown above.";
  String get exchange_result_write_down_trade_id => "Please copy or write down the trade ID to continue.";
  String get expired => "Expired";
  String get faq => "FAQ";
  String get fetching => "Fetching";
  String get filters => "Filters";
  String get first_wallet_text => "Awesome wallet\nfor Monero";
  String get id => "ID: ";
  String get incoming => "Incoming";
  String get loading_your_wallet => "Loading your wallet";
  String get login => "Login";
  String get new_wallet => "New Wallet";
  String get node_address => "Node Address";
  String get node_new => "New Node";
  String get node_port => "Node port";
  String get node_reset_settings_title => "Reset settings";
  String get nodes => "Nodes";
  String get nodes_list_reset_to_default_message => "Are you sure that you want to reset settings to default?";
  String get offer_expires_in => "Offer expires in: ";
  String get ok => "OK";
  String get outgoing => "Outgoing";
  String get password => "Password";
  String get payment_id => "Payment ID: ";
  String get pending => " (pending)";
  String get please_make_selection => "Please make selection below to\ncreate or recover your wallet.";
  String get please_select => "Please select:";
  String get please_try_to_connect_to_another_node => "Please try to connect to another node";
  String get receive => "Receive";
  String get receive_amount => "Amount";
  String get received => "Received";
  String get reconnect => "Reconnect";
  String get reconnect_alert_text => "Are you sure to reconnect?";
  String get reconnection => "Reconnection";
  String get remove => "Remove";
  String get remove_node => "Remove node";
  String get remove_node_message => "Are you sure that you want to remove selected node?";
  String get rescan => "Rescan";
  String get reset => "Reset";
  String get restore_address => "Address";
  String get restore_description_from_backup => "You can restore the whole Cake Wallet app from\nyour back-up file";
  String get restore_description_from_keys => "Restore your wallet from generated\nkeystrokes saved from your private keys";
  String get restore_description_from_seed => "Restore your wallet from either the 25 word\nor 13 word combination code";
  String get restore_description_from_seed_keys => "Get back your wallet from seed/keys that you've saved to secure place";
  String get restore_next => "Next";
  String get restore_recover => "Recover";
  String get restore_restore_wallet => "Restore Wallet";
  String get restore_seed_keys_restore => "Seed/Keys Restore";
  String get restore_spend_key_private => "Spend key (private)";
  String get restore_title_from_backup => "Restore from a back-up file";
  String get restore_title_from_keys => "Restore from keys";
  String get restore_title_from_seed => "Restore from seed";
  String get restore_title_from_seed_keys => "Restore from seed/keys";
  String get restore_view_key_private => "View key (private)";
  String get restore_wallet => "Restore wallet";
  String get restore_wallet_name => "Wallet name";
  String get restore_wallet_restore_description => "Wallet restore description";
  String get save => "Save";
  String get saved_the_trade_id => "I've saved the trade ID";
  String get seed_alert_first_text => "The next page will show\nyou a seed.";
  String get seed_alert_menu => " menu.";
  String get seed_alert_second_text => "Please write these down just in\ncase you lose or wipe your phone.";
  String get seed_alert_settings => "settings";
  String get seed_alert_third_text => "You can also see the seed again\nin the ";
  String get seed_alert_understand => "I understand";
  String get seed_share => "Share seed";
  String get seed_title => "Seed";
  String get send => "Send";
  String get send_creating_transaction => "Creating transaction";
  String get send_error_currency => "Currency can only contain numbers";
  String get send_error_minimum_value => "Minimum value of amount is 0.01";
  String get send_estimated_fee => "Estimated fee:";
  String get send_monero_address => "Monero address";
  String get send_payment_id => "Payment ID (optional)";
  String get send_title => "Send Monero";
  String get send_your_wallet => "Your wallet";
  String get sending => "Sending";
  String get sent => "Sent";
  String get share_address => "Share address";
  String get show_keys => "Show keys";
  String get show_seed => "Show seed";
  String get status => "Status: ";
  String get subaddresses => "Subaddresses";
  String get today => "Today";
  String get trades => "Trades";
  String get transaction_sent => "Transaction sent!";
  String get transactions => "Transactions";
  String get transactions_by_date => "Transactions by date";
  String get use => "Use ";
  String get wallet_menu => "Wallet Menu";
  String get wallet_name => "Wallet name";
  String get wallets => "Wallets";
  String get welcome => "WELCOME\nTO CAKE WALLET";
  String get xmr_available_balance => "XMR Available Balance";
  String get xmr_full_balance => "XMR Full Balance";
  String get xmr_hidden => "XMR Hidden";
  String get yesterday => "Yesterday";
  String get you_will_get => "You will get";
  String get you_will_send => "You will send";
  String Blocks_remaining(String status) => "${status} Blocks Remaining";
  String change_current_node(String node) => "Are you sure to change current node to ${node}?";
  String commit_transaction_amount_fee(String amount, String fee) => "Commit transaction\nAmount: ${amount}\nFee: ${fee}";
  String exchange_result_confirm(String fetchingLabel, String from, String walletName) => "By pressing confirm, you will be sending ${fetchingLabel} ${from} from your wallet called ${walletName} to the address shown above. Or you can send from your external wallet to the above address/QR code.\n\nPlease press confirm to continue or go back to change the amounts.\n\n";
  String exchange_result_description(String fetchingLabel, String from) => "Please send ${fetchingLabel} ${from} to the address shown above.\n\n'";
  String failed_authentication(String state_error) => "Failed authentication. ${state_error}";
  String max_value(String value, String currency) => "Max: ${value} ${currency}";
  String min_value(String value, String currency) => "Min: ${value} ${currency}";
  String powered_by(String title) => "Powered by ${title}";
  String send_priority(String transactionPriority) => "Currently the fee is set at ${transactionPriority} priority.\nTransaction priority can be adjusted in the settings";
  String time(String minutes, String seconds) => "${minutes}m ${seconds}s";
  String trade_id(String id) => "Trade ID:\n${id}";
  String trade_is_powered_by(String provider) => "This trade is powered by ${provider}";
}

class $ru extends S {
  const $ru();

  @override
  TextDirection get textDirection => TextDirection.ltr;

}

class $en extends S {
  const $en();
}

class GeneratedLocalizationsDelegate extends LocalizationsDelegate<S> {
  const GeneratedLocalizationsDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale("ru", ""),
      Locale("en", ""),
    ];
  }

  LocaleListResolutionCallback listResolution({Locale fallback, bool withCountry = true}) {
    return (List<Locale> locales, Iterable<Locale> supported) {
      if (locales == null || locales.isEmpty) {
        return fallback ?? supported.first;
      } else {
        return _resolve(locales.first, fallback, supported, withCountry);
      }
    };
  }

  LocaleResolutionCallback resolution({Locale fallback, bool withCountry = true}) {
    return (Locale locale, Iterable<Locale> supported) {
      return _resolve(locale, fallback, supported, withCountry);
    };
  }

  @override
  Future<S> load(Locale locale) {
    final String lang = getLang(locale);
    if (lang != null) {
      switch (lang) {
        case "ru":
          S.current = const $ru();
          return SynchronousFuture<S>(S.current);
        case "en":
          S.current = const $en();
          return SynchronousFuture<S>(S.current);
        default:
          // NO-OP.
      }
    }
    S.current = const S();
    return SynchronousFuture<S>(S.current);
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale, true);

  @override
  bool shouldReload(GeneratedLocalizationsDelegate old) => false;

  ///
  /// Internal method to resolve a locale from a list of locales.
  ///
  Locale _resolve(Locale locale, Locale fallback, Iterable<Locale> supported, bool withCountry) {
    if (locale == null || !_isSupported(locale, withCountry)) {
      return fallback ?? supported.first;
    }

    final Locale languageLocale = Locale(locale.languageCode, "");
    if (supported.contains(locale)) {
      return locale;
    } else if (supported.contains(languageLocale)) {
      return languageLocale;
    } else {
      final Locale fallbackLocale = fallback ?? supported.first;
      return fallbackLocale;
    }
  }

  ///
  /// Returns true if the specified locale is supported, false otherwise.
  ///
  bool _isSupported(Locale locale, bool withCountry) {
    if (locale != null) {
      for (Locale supportedLocale in supportedLocales) {
        // Language must always match both locales.
        if (supportedLocale.languageCode != locale.languageCode) {
          continue;
        }

        // If country code matches, return this locale.
        if (supportedLocale.countryCode == locale.countryCode) {
          return true;
        }

        // If no country requirement is requested, check if this locale has no country.
        if (true != withCountry && (supportedLocale.countryCode == null || supportedLocale.countryCode.isEmpty)) {
          return true;
        }
      }
    }
    return false;
  }
}

String getLang(Locale l) => l == null
  ? null
  : l.countryCode != null && l.countryCode.isEmpty
    ? l.languageCode
    : l.toString();
